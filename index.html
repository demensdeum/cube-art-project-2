<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Three.js FPS + GUI + Resize</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #instructions {
      position: absolute;
      top: 50%;
      width: 100%;
      text-align: center;
      color: white;
      font-size: 24px;
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="instructions">Click to play</div>

<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js';
  import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm';

  // === PointerLockControls (inline) ===
  class PointerLockControls extends THREE.EventDispatcher {
    constructor(camera, domElement) {
      super();
      this.domElement = domElement;
      this.isLocked = false;

      const scope = this;
      const euler = new THREE.Euler(0, 0, 0, 'YXZ');
      const PI_2 = Math.PI / 2;

      function onMouseMove(event) {
        if (!scope.isLocked) return;
        const movementX = event.movementX || 0;
        const movementY = event.movementY || 0;
        euler.setFromQuaternion(camera.quaternion);
        euler.y -= movementX * 0.002;
        euler.x -= movementY * 0.002;
        euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
        camera.quaternion.setFromEuler(euler);
      }

      function onPointerlockChange() {
        scope.isLocked = document.pointerLockElement === domElement;
      }

      function onPointerlockError() {
        console.error('PointerLockControls: Unable to use Pointer Lock API');
      }

      this.connect = function () {
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('pointerlockchange', onPointerlockChange);
        document.addEventListener('pointerlockerror', onPointerlockError);
      };

      this.getObject = () => camera;
      this.lock = () => domElement.requestPointerLock();
      this.unlock = () => document.exitPointerLock();

      this.getDirection = () => {
        const direction = new THREE.Vector3(0, 0, -1);
        return v => v.copy(direction).applyQuaternion(camera.quaternion);
      };

      this.moveForward = (distance) => {
        const vec = new THREE.Vector3();
        this.getDirection()(vec);
        camera.position.addScaledVector(vec, distance);
      };

      this.moveRight = (distance) => {
        const vec = new THREE.Vector3();
        this.getDirection()(vec);
        vec.cross(camera.up);
        camera.position.addScaledVector(vec, distance);
      };

      this.connect();
    }
  }

  // === Cube Data ===
  const data = {
    cubes: [
      [-1, 1, 0, 0xff0000],
      [ 0, 1, 0, 0x00ff00],
      [ 1, 1, 0, 0x0000ff],
      [ 0, 0, 0, 0xffff00],
      [ 0, 2, 0, 0xff00ff]
    ]
  };

  // === Scene Setup ===
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 1.5, 5);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // === Lights ===
  // const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  // scene.add(ambientLight);
  // const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  // directionalLight.position.set(5, 10, 5);
  // scene.add(directionalLight);

  // === Grid + Axes (debug)
  const gridHelper = new THREE.GridHelper(10, 10);
  scene.add(gridHelper);
  const axesHelper = new THREE.AxesHelper(2);
  scene.add(axesHelper);

  // === Create Cubes
  const geometry = new THREE.BoxGeometry(1, 1, 1);
  data.cubes.forEach(([x, y, z, hex]) => {
    const material = new THREE.MeshBasicMaterial({ color: hex });
    const cube = new THREE.Mesh(geometry, material);
    cube.position.set(x, y, z);
    scene.add(cube);
  });

  // === Controls
  const controls = new PointerLockControls(camera, document.body);
  scene.add(controls.getObject());

  const instructions = document.getElementById('instructions');
  instructions.addEventListener('click', () => controls.lock());

  document.addEventListener('pointerlockchange', () => {
  const isLocked = document.pointerLockElement === document.body;
  instructions.style.display = isLocked ? 'none' : '';
});

const cursorMaterial = new THREE.MeshBasicMaterial({
  color: 0xffffff,
  opacity: 0.5,
  transparent: true
});

const cursorCube = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  cursorMaterial
);

cursorCube.renderOrder = 999; // ensure it's drawn on top
scene.add(cursorCube);



  // === Movement
  const move = { forward: false, backward: false, left: false, right: false, up: false };
  const velocity = new THREE.Vector3();
  const direction = new THREE.Vector3();
  const speed = 5;

  document.addEventListener('keydown', e => {
    if (e.code === 'KeyW') move.forward = true;
    if (e.code === 'KeyS') move.backward = true;
    if (e.code === 'KeyA') move.left = true;
    if (e.code === 'KeyD') move.right = true;
    if (e.code === 'Space') move.up = true;
  });

  document.addEventListener('keyup', e => {
    if (e.code === 'KeyW') move.forward = false;
    if (e.code === 'KeyS') move.backward = false;
    if (e.code === 'KeyA') move.left = false;
    if (e.code === 'KeyD') move.right = false;
    if (e.code === 'Space') move.up = false;
    if (e.code === 'KeyF') placeCubeInFront();
  });

  function placeCubeInFront() {
  const distance = 3;
  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);

  const position = new THREE.Vector3();
  position.copy(camera.position).add(dir.multiplyScalar(distance));

  // Snap to grid
  position.x = Math.round(position.x);
  position.y = Math.round(position.y);
  position.z = Math.round(position.z);

  // Search for existing cube
  const existingIndex = data.cubes.findIndex(([x, y, z]) =>
    x === position.x && y === position.y && z === position.z
  );

  if (existingIndex !== -1) {
    // ✅ Remove cube from scene
    const toRemove = scene.children.find(obj =>
      obj.isMesh &&
      obj.geometry.type === 'BoxGeometry' &&
      obj.position.x === position.x &&
      obj.position.y === position.y &&
      obj.position.z === position.z &&
      obj != cursorCube
    );
    if (toRemove) scene.remove(toRemove);

    // ✅ Remove from data.cubes
    data.cubes.splice(existingIndex, 1);
    return;
  }

  // ➕ Otherwise, place new cube
  const hexColor = new THREE.Color(options.cubeColor).getHex();
  const material = new THREE.MeshBasicMaterial({ color: hexColor });
  const cube = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), material);
  cube.position.copy(position);
  scene.add(cube);

  data.cubes.push([position.x, position.y, position.z, hexColor]);
}


  // === GUI controls for grid and axes
  const gui = new GUI();
  const options = {
    grid: true,
    axes: true,
    cubeColor: '#ffffff'
  };
  gui.add(options, 'grid').name('Show Grid').onChange(v => gridHelper.visible = v);
  gui.add(options, 'axes').name('Show Axes').onChange(v => axesHelper.visible = v);
  gui.addColor(options, 'cubeColor').name('Cube Color');

  // === Animate
  const clock = new THREE.Clock();
  function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();

    direction.z = Number(move.forward) - Number(move.backward);
    direction.x = Number(move.right) - Number(move.left);
    direction.normalize();

    if (controls.isLocked) {
      velocity.x = direction.x * speed * delta;
      velocity.z = direction.z * speed * delta;
      velocity.y = move.up ? speed * delta : 0;

      controls.moveRight(velocity.x);
      controls.moveForward(velocity.z);
      camera.position.y += velocity.y;
    }

    const dir = new THREE.Vector3();
camera.getWorldDirection(dir);
const pos = new THREE.Vector3().copy(camera.position).add(dir.multiplyScalar(3));
pos.x = Math.round(pos.x);
pos.y = Math.round(pos.y);
pos.z = Math.round(pos.z);
cursorCube.position.copy(pos);
cursorMaterial.color.set(options.cubeColor); // match GUI color


    renderer.render(scene, camera);
  }

  animate();

  // === Resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
