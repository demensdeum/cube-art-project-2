<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Three.js Instancing RGB Cubes</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #instructions {
      position: absolute;
      width: 100%;
      height: 100%;
      text-align: center;
      color: white;
      font-size: 24px;
      user-select: none;
      padding-top: 20vh;
    }
  </style>
</head>
<body>
<div id="instructions">Click to enter</div>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js';
import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm';

class PointerLockControls extends THREE.EventDispatcher {
  constructor(camera, domElement) {
    super();
    this.domElement = domElement;
    this.isLocked = false;

    const scope = this;
    const euler = new THREE.Euler(0, 0, 0, 'YXZ');
    const PI_2 = Math.PI / 2;

    function onMouseMove(event) {
      if (!scope.isLocked) return;
      const movementX = event.movementX || 0;
      const movementY = event.movementY || 0;
      euler.setFromQuaternion(camera.quaternion);
      euler.y -= movementX * 0.002;
      euler.x -= movementY * 0.002;
      euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
      camera.quaternion.setFromEuler(euler);
    }

    function onPointerlockChange() {
      scope.isLocked = document.pointerLockElement === domElement;
    }

    function onPointerlockError() {
      console.error('PointerLockControls: Unable to use Pointer Lock API');
    }

    this.connect = function () {
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('pointerlockchange', onPointerlockChange);
      document.addEventListener('pointerlockerror', onPointerlockError);
    };

    this.getObject = () => camera;
    this.lock = () => domElement.requestPointerLock();
    this.unlock = () => document.exitPointerLock();

    this.getDirection = () => {
      const direction = new THREE.Vector3(0, 0, -1);
      return v => v.copy(direction).applyQuaternion(camera.quaternion);
    };

    this.moveForward = (distance) => {
      const vec = new THREE.Vector3();
      this.getDirection()(vec);
      camera.position.addScaledVector(vec, distance);
    };

    this.moveRight = (distance) => {
      const vec = new THREE.Vector3();
      this.getDirection()(vec);
      vec.cross(camera.up);
      camera.position.addScaledVector(vec, distance);
    };

    this.connect();
  }
}

// === Setup ===
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 1.5, 5);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// === GUI options ===
const options = {
  cubeColor: '#ffffff',
  speed: 10,
  backgroundColor: '#000000',
  grid: false,
  axes: false,
  cursorVisible: true
};

const gui = new GUI();
gui.addColor(options, 'cubeColor').name('Cube Color');
gui.add(options, 'speed', 0.1, 50, 0.1).name('Speed');
gui.addColor(options, 'backgroundColor').name('Background').onChange(color => {
  renderer.setClearColor(color);
});
gui.add(options, 'grid').name('Show Grid').onChange(v => gridHelper.visible = v);
gui.add(options, 'axes').name('Show Axes').onChange(v => axesHelper.visible = v);
gui.add(options, 'cursorVisible').name('Show Cursor');
gui.add({ save: saveSceneToFile }, 'save').name('ðŸ’¾ Save Scene');
gui.add({ load: loadSceneFromFile }, 'load').name('ðŸ“‚ Load Scene');

// === Helpers ===
const gridHelper = new THREE.GridHelper(20, 20);
scene.add(gridHelper);
const axesHelper = new THREE.AxesHelper(3);
scene.add(axesHelper);

// === Controls ===
const controls = new PointerLockControls(camera, document.body);
scene.add(controls.getObject());
document.getElementById('instructions').addEventListener('click', () => controls.lock());
document.addEventListener('pointerlockchange', () => {
  document.getElementById('instructions').style.display = document.pointerLockElement === document.body ? 'none' : '';
});

// === Movement ===
const move = { forward: false, backward: false, left: false, right: false, up: false };
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();

document.addEventListener('keydown', e => {
  if (e.code === 'KeyW') move.forward = true;
  if (e.code === 'KeyS') move.backward = true;
  if (e.code === 'KeyA') move.left = true;
  if (e.code === 'KeyD') move.right = true;
  if (e.code === 'Space') move.up = true;
});
document.addEventListener('keyup', e => {
  if (e.code === 'KeyW') move.forward = false;
  if (e.code === 'KeyS') move.backward = false;
  if (e.code === 'KeyA') move.left = false;
  if (e.code === 'KeyD') move.right = false;
  if (e.code === 'Space') move.up = false;
  if (e.code === 'KeyF') placeCubeInFront();
});

// === Cursor Cube ===
const cursorMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true });
const cursorCube = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), cursorMaterial);
cursorCube.renderOrder = 999;
scene.add(cursorCube);

// === Data & Instancing ===
const geometry = new THREE.BoxGeometry(1, 1, 1);
let instancedMesh;
const dummy = new THREE.Object3D();
const maxCubes = 180000;

const data = {
  cubes: [
    [-1, 1, 0, 0xff0000],
    [ 0, 1, 0, 0x00ff00],
    [ 1, 1, 0, 0x0000ff],
    [ 0, 0, 0, 0xffff00],
    [ 0, 2, 0, 0xff00ff]
  ]
};

const material = new THREE.ShaderMaterial({
  vertexShader: `
    attribute vec3 instanceColor;
    varying vec3 vColor;
    void main() {
      vColor = instanceColor;
      gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    varying vec3 vColor;
    void main() {
      gl_FragColor = vec4(vColor, 1.0);
    }
  `
});

function buildInstancedMesh() {
  if (instancedMesh) scene.remove(instancedMesh);

  const count = data.cubes.length;
  instancedMesh = new THREE.InstancedMesh(geometry, material, maxCubes);
  const colors = new Float32Array(maxCubes * 3);

  data.cubes.forEach(([x, y, z, hex], i) => {
    dummy.position.set(x, y, z);
    dummy.updateMatrix();
    instancedMesh.setMatrixAt(i, dummy.matrix);

    const color = new THREE.Color(hex);
    colors.set([color.r, color.g, color.b], i * 3);
  });

  geometry.setAttribute('instanceColor', new THREE.InstancedBufferAttribute(colors, 3));
  scene.add(instancedMesh);
}
buildInstancedMesh();

// === Place Cube ===
function placeCubeInFront() {
  const distance = 3;
  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  const pos = new THREE.Vector3().copy(camera.position).add(dir.multiplyScalar(distance));
  pos.x = Math.round(pos.x);
  pos.y = Math.round(pos.y);
  pos.z = Math.round(pos.z);

  const index = data.cubes.findIndex(([x, y, z]) => x === pos.x && y === pos.y && z === pos.z);
  if (index !== -1) {
    data.cubes.splice(index, 1);
  } else {
    const hex = new THREE.Color(options.cubeColor).getHex();
    data.cubes.push([pos.x, pos.y, pos.z, hex]);
  }

  buildInstancedMesh();
}

// === Click to place cube
document.body.addEventListener('click', () => {
  if (document.pointerLockElement === document.body) {
    placeCubeInFront();
  }
});

// === Save/Load
function saveSceneToFile() {
  const cameraData = {
    position: [camera.position.x, camera.position.y, camera.position.z],
    rotation: [camera.rotation.x, camera.rotation.y, camera.rotation.z]
  };
  const sceneData = {
    camera: cameraData,
    cubes: data.cubes,
    backgroundColor: options.backgroundColor
  };
  const blob = new Blob([JSON.stringify(sceneData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'scene.cartp2';
  a.click();
  URL.revokeObjectURL(url);
}

function loadSceneFromFile() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.cartp2,application/json';
  input.onchange = e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = ev => {
      try {
        const json = JSON.parse(ev.target.result);
        data.cubes = Array.isArray(json) ? json : json.cubes;
        if (json.camera) {
          const [x, y, z] = json.camera.position;
          const [rx, ry, rz] = json.camera.rotation;
          camera.position.set(x, y, z);
          camera.rotation.set(rx, ry, rz);
        }
        if (json.backgroundColor) {
          options.backgroundColor = json.backgroundColor;
          renderer.setClearColor(json.backgroundColor);
        }
        buildInstancedMesh();
      } catch (err) {
        alert('Failed to load scene: ' + err.message);
      }
    };
    reader.readAsText(file);
  };
  input.click();
}

// === Animate
const clock = new THREE.Clock();
function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();

  direction.z = Number(move.forward) - Number(move.backward);
  direction.x = Number(move.right) - Number(move.left);
  direction.normalize();

  if (controls.isLocked) {
    velocity.x = direction.x * options.speed * delta;
    velocity.z = direction.z * options.speed * delta;
    velocity.y = move.up ? options.speed * delta : 0;
    controls.moveRight(velocity.x);
    controls.moveForward(velocity.z);
    camera.position.y += velocity.y;
  }

  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  const pos = new THREE.Vector3().copy(camera.position).add(dir.multiplyScalar(3));
  pos.x = Math.round(pos.x);
  pos.y = Math.round(pos.y);
  pos.z = Math.round(pos.z);
  cursorCube.position.copy(pos);
  cursorMaterial.opacity = options.cursorVisible ? 0.5 : 0.0;
  cursorMaterial.visible = options.cursorVisible;

  renderer.setClearColor(options.backgroundColor);
  renderer.render(scene, camera);
}
animate();

// === Resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
